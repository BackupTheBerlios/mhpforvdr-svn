
package org.dvb.io.ixc;

import org.dvb.application.MHPApplication;
import org.dvb.application.AppID;

import java.util.Hashtable;
import java.util.Collection;
import java.util.Iterator;

/*This is the bootstrap mechanism for obtaining references to remote objects residing in 
other Xlets executing on the same MHP terminal, using a URL-like syntax. The identi cation 
of a remote object is given using a syntax indicating the organisation ID and application 
ID: /organisation_id/application_id/name organisation_id = the organisation ID of the 
Xlet, as signalled in the application_identi er record, de ned in the MHP speci cation. 
application_id = the application ID of the Xlet, as signalled in the application_identi er 
record, de ned in the MHP speci cation. name = the name under which the remote object was 
exported. The organisation ID and the application ID shall be encoded as a hexadecimal 
string, as would be accepted by java.lang.Integer.parseInt(String s, 16). When RMI is used 
to communicate over a network, stubs generated by a tool like rmic are often required. 
This is not necessary for inter-xlet communication initiated with IxcRegistry. If such 
stubs are present, they shall be ignored. Similarly, network RMI objects often extend the 
class server.RemoteObject, in order to get appropriate implementations for 
Object.hashCode(), Object.equals(), and Object.toString(). Overriding Object's 
implementation of these methods in this way is not necessary for inter-xlet communication 
initiated with IxcRegistry, although it is not harmful. Note that the class 
server.RemoteObject is not required in all MHP pro les. */

//In the current implementation, all xlets are executed in the same VM, so there is not much
//necessity for this class, and implementation is trivial.

public class IxcRegistry {

static Hashtable hash = new Hashtable();

static class Binding {
   // Format: /organisation_id/application_id/name 
   String path;
   int aid,oid;
   boolean external;
   java.rmi.Remote obj;
   
   Binding(int aid, int oid, String name, java.rmi.Remote obj, boolean external) {
      this.aid=aid;
      this.oid=oid;
      this.external=external;
      this.obj=obj;
      buildName(name);
   }
   
   Binding(String path, boolean external) throws IllegalArgumentException {
      this.external=external;
      this.path=path;
      
      if (!path.startsWith("/"))
         throw new IllegalArgumentException("No \"/\" at the beginning");
         
      int secondSlash=path.indexOf("/", 1);
      if (secondSlash == -1)
         throw new IllegalArgumentException("No \"/\" after the organisation ID");
      try {
         oid=Integer.parseInt(path.substring(1, secondSlash), 16);
      } catch (NumberFormatException e) {
         throw new IllegalArgumentException("Illegally formatted organisation ID");
      }
         
      int thirdSlash=path.indexOf("/", secondSlash+1);
      if (thirdSlash == -1)
         throw new IllegalArgumentException("No \"/\" after the application ID");
      try {
         aid=Integer.parseInt(path.substring(secondSlash+1, thirdSlash), 16);
      } catch (NumberFormatException e) {
         throw new IllegalArgumentException("Illegally formatted application ID");
      }
      
      //String name = path.substring(thirdSlash+1);
   }
   
   public String getPath() {
      return path;   
   }
   
   public java.rmi.Remote getRemoteObject() {
      return obj;
   }
   
   public boolean isVisibleFor(AppID id) {
      return external || (id.getAID()==aid && id.getOID()==oid);
   }
   
   public boolean equals(Object obj) {
      if (obj instanceof Binding)
         return ((Binding)obj).path.equals(path);
      return false;
   }
   
   public int hashCode() {
      return path.hashCode();
   }
   
   private void buildName(String name) {
      path="/" + Integer.toString(oid, 16) + "/" + Integer.toString(aid, 16) + "/" + name;
   }
   
}

/*
Binds a remote object under a given name in the namespace of an Xlet. The name can be any valid non-null String. No 
hierarchical namespace exists, e.g. the names "foo" and "bar/../foo" are distinct. If the exporting xlet has been 
destroyed, this method may fail silently. The object shall be made visible to other applications. A call to bind(xc, 
name, obj) is thus equivalent to a call to bind(xc, name, obj, true). Parameters: xc - The context of the Xlet exporting 
the object. name - The name identifying the object. obj - The object being exported Throws: AlreadyBoundException - if 
this Xlet has previously exported an object under the given name. NullPointerException - if xc, name or obj is 
null */
public static void bind(javax.tv.xlet.XletContext xc, java.lang.String name, java.rmi.Remote obj) 
  throws java.rmi.AlreadyBoundException, NullPointerException
{
   bind(xc, name, obj, true);
}

/*
Binds a remote object under a given name in the namespace of an Xlet. The name can be any valid non-null String. No 
hierarchical namespace exists, e.g. the names "foo" and "bar/../foo" are distinct. If the exporting xlet has been 
destroyed, this method may fail silently. Parameters: xc - The context of the Xlet exporting the object. name - The name 
identifying the object. obj - The object being exported external - Determines if this object is exported outside the 
scope of the current application, as de ned in this speci cation. If set true, the object shall be visible to other 
applications; if false, it shall only be visible to Xlets within the same application. Note that an embedded Xlet with a 
different app ID than its enclosing HTML page is still considered to be the same application as that which contains the 
enclosing page. Throws: AlreadyBoundException - if this Xlet has previously exported an object under the given name. 
NullPointerException - if xc, name or obj is null Since: MHP 1.1 */
public static void bind(javax.tv.xlet.XletContext xc, java.lang.String name, java.rmi.Remote obj, boolean external) 
  throws java.rmi.AlreadyBoundException
{
   if (xc==null || name==null || obj==null)
      throw new NullPointerException();
   
   //in the implementation, XletContext is only implemented by subclasses of MHPApplication
   if (!(xc instanceof MHPApplication))
      return; //what to do?
      
   AppID id=((MHPApplication)xc).getIdentifier();
   Binding b=new Binding(id.getAID(), id.getOID(), name, obj, external);
   String path=b.getPath();
   
   //Hashtable is synchronized internally, but we need this enclosing lock for list()
   synchronized(IxcRegistry.class) {   
      if (hash.containsKey(path))
         throw new java.rmi.AlreadyBoundException();
      
      hash.put(path, b);
   }
}

/*
Returns an array of string paths objects available in the registry. The array contains a snapshot of the names present 
in the registry that the current Xlet would be allowed to import using IxcRegistry. lookup. Parameters: xc - The context 
of the current Xlet. Returns: A non-null array of strings containing a snapshot of the path names of all objects 
available to the caller in this registry. See Also: lookup(XletContext, String) */
public static java.lang.String[] list(javax.tv.xlet.XletContext xc) {
   //in the implementation, XletContext is only implemented by subclasses of MHPApplication
   if (!(xc instanceof MHPApplication))
      return new String[0]; //what to do?
      
   AppID id=((MHPApplication)xc).getIdentifier();
   
   synchronized(IxcRegistry.class) {
      String[] temp=new String[hash.size()];
      Collection c = hash.values();
      Iterator it=c.iterator();
      Binding b;
      int i;
      for (i=0;it.hasNext();i++) {
         b=(Binding)it.next();
         if (b.isVisibleFor(id))
            temp[i]=b.getPath();
      }
      String[] ret=new String[i];
      System.arraycopy(temp, 0, ret, 0, i);
      return ret;
   }
}

/*
Returns a remote object previously exported by an Xlet that has not been destroyed. The identi cation of a remote object 
is given using a syntax indicating the organisation ID and application ID: /organisation_id/application_id/name 
organisation_id = the organisation ID of the Xlet, as signalled in the application_identi er record. application_id = 
the applicatin ID of the Xlet, as signalled in the application_identi er record. name = the name under which the remote 
object was exported. The organisation ID and the application ID shall be encoded as a hexadecimal string, as would be 
accepted by java.lang.Integer.parseInt(String s, 16). If the caller is not authorized to import a given object due to 
the security policy, then this API will behave as though the object had not been exported, that is, a NotBoundException 
shall be thrown. Parameters: xc - The context of the current Xlet (that is, the Xlet importing the object). path - A  le 
pathname-like string identifying the Xlet and the name of the object to be imported. Returns: A remote object Throws: 
NotBoundException - If the name is not currently bound. RemoteException - If a remote stub class cannot be generated for 
the object being imported. java.lang.IllegalArgumentException - If the name is not formatted in the syntax given above. 
NullPointerException - if path is null */
public static java.rmi.Remote lookup(javax.tv.xlet.XletContext xc, java.lang.String path) 
 throws java.rmi.NotBoundException, IllegalArgumentException
{
   //in the implementation, XletContext is only implemented by subclasses of MHPApplication
   if (!(xc instanceof MHPApplication))
      return null; //what to do?
      
   Binding b=(Binding)hash.get(path);
   
   if (b==null)
      throw new java.rmi.NotBoundException();
      
   AppID id=((MHPApplication)xc).getIdentifier();
   if (!b.isVisibleFor(id))
      throw new java.rmi.NotBoundException("Not authorized");
      
   //If this was a non-trivial implementation, at this point we would have to construct 
   //a stub (adapter) object to do the actual communications.
   return b.getRemoteObject();
}

/*
Rebind the name to a new object in the context of an Xlet; replaces any existing binding. The name can be any valid 
non-null String. No hierarchical namespace exists, e.g. the names "foo" and "bar/../ foo" are distinct. If the exporting 
xlet has been destroyed, this method may fail silently. The object shall be made visible to other applications. A call 
to rebind(xc, name, obj) is thus equivalent to a call to rebind(xc, name, obj, true). Parameters: xc - The context of 
the Xlet that exported the object. name - The name identifying the object. obj - The object being exported Throws: 
NullPointerException - if xc, name or obj is null */
public static void rebind(javax.tv.xlet.XletContext xc, java.lang.String name, java.rmi.Remote obj) {
   rebind(xc, name, obj, true);
}

/*
Rebind the name to a new object in the context of an Xlet; replaces any existing binding. The name can be any valid 
non-null String. No hierarchical namespace exists, e.g. the names "foo" and "bar/../ foo" are distinct. If the exporting 
xlet has been destroyed, this method may fail silently. Parameters: xc - The context of the Xlet that exported the 
object. name - The name identifying the object. obj - The object being exported external - Determines if this object is 
exported outside the scope of the current application, as de ned in this speci cation. If set true, the object shall be 
visible to other applications; if false, it shall only be visible to Xlets within the same application. Note that an 
embedded Xlet with a different app ID than its enclosing HTML page is still considered to be the same application as 
that which contains the enclosing page. Throws: NullPointerException - if xc, name or obj is 
null */
public static void rebind(javax.tv.xlet.XletContext xc, java.lang.String name, java.rmi.Remote obj, boolean 
external) {
   if (xc==null || name==null || obj==null)
      throw new NullPointerException();
   //in the implementation, XletContext is only implemented by subclasses of MHPApplication
   if (!(xc instanceof MHPApplication))
      return;
      
   AppID id=((MHPApplication)xc).getIdentifier();
   Binding b=new Binding(id.getAID(), id.getOID(), name, obj, external);
   String path=b.getPath();
   
   synchronized(IxcRegistry.class) {   
      hash.put(path, b);
   }
}

/*
Unbind the name. Parameters: xc - The context of the Xlet that exported the object to be unbound. name - The name 
identifying the object. Throws: NotBoundException - if this is not currently any object exported by this Xlet under the 
given name. NullPointerException - if xc or name is null */
public static void unbind(javax.tv.xlet.XletContext xc, java.lang.String name) 
   throws java.rmi.NotBoundException
{
   if (xc==null || name==null)
      throw new NullPointerException();
   //in the implementation, XletContext is only implemented by subclasses of MHPApplication
   if (!(xc instanceof MHPApplication))
      return;
      
   //construct path
   AppID id=((MHPApplication)xc).getIdentifier();
   Binding b=new Binding(id.getAID(), id.getOID(), name, null, true);
   String path=b.getPath();
   
   synchronized(IxcRegistry.class) {
      if (hash.remove(path)==null)
         throw new java.rmi.NotBoundException();
   }
}


}
